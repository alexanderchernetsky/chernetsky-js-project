<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="stylesheet" href="style.css">
    <title>racing game project</title>
  </head>
  <body>
    <div class="canvas-wrapper"></div>
    <div class="game-end-wrapper">
      <p class="info">
        <span>game over!</span><br>
        <span id="score"></span>
      </p>
      <input id="player-name" type="text" placeholder="enter your name"><br>
      <input type="button" value="save result"><br>
      <input type="button" value="high scores"><br>
      <input type="button" value="new game"><br>
      <input type="button" value="main menu"><br>
    </div>
    <div class="game-end-background"></div>
    <script>
      'use strict';
      // constants
      var GAMEAREAWIDTH = 500; // width of our game area
      var GAMEAREAHEIGHT = 600; // height of our game area
      var PLAYERCARWIDTH = 50; // width of user car
      var PLAYERCARHEIGHT = 100; // height of user car
      var OBSTACLEWIDTH = 50; // width of obstacle
      var OBSTACLEHEIGHT = 100; // height of obstacle
      var SCORESIZE = 20; // the size of our score
      var BACKGROUNDIMAGEHEIGHT = 1349; //  it should be equal to full height of our background image
      var ACCELERATION = 0.001; // game speed acceleration


      var playerCar; // declare variable of user car
      var obstacles = [];// variable for our obstacles
      var obstacleSpeed = 2; // initial speed of moving obstacle = 2
      var playerScore; // declare variable of user score
      var background; // declare variable of game background
      var backgroundSpeed = 1; // initial speed od background moving
      var crashSound; //declare variable of crash car sound
      var song; // declare variable of game music



      // game area object
      var myGameArea = {
        canvas : document.createElement("canvas"),
        start : function() {
          this.canvas.width = GAMEAREAWIDTH;
          this.canvas.height = GAMEAREAHEIGHT;
          this.context = this.canvas.getContext("2d");
          document.querySelector('.canvas-wrapper').appendChild(this.canvas);
        },
        clear: function () {
          this.context.clearRect(0 , 0, GAMEAREAWIDTH, GAMEAREAHEIGHT);
        },
        frameNo: 0,
      };

      // creating empty game area canvas with background, car and score
      (function startGame() {
        myGameArea.start();
        background = new Background(GAMEAREAWIDTH, BACKGROUNDIMAGEHEIGHT, 0, 0, 'img/road.jpg');
        playerCar = new Car(PLAYERCARWIDTH, PLAYERCARHEIGHT, 230, 500, 'img/player-car.png');
        playerScore = new Counter(SCORESIZE, 20, 20);
        crashSound = new Sound('sounds/crash.mp3');
        song = new Sound('sounds/song.mp3');
      }());


      // constructor for score counter
      function Counter (size, x, y) {
        var self = this;
        self.text = 'SCORE:';
        self.update = function () {
          var ctx = myGameArea.context;
          ctx.fillStyle = 'white';
          ctx.font = 'italic bold ' + size + 'px Arial';
          ctx.fillText(self.text, x, y);
        };
      }

      function Sound(src) {
        var self = this;
        self.sound = document.createElement('audio');
        self.sound.src = src;
        self.sound.style.display = 'none';
        document.body.appendChild(self.sound);
        self.play = function () {
          self.sound.play();
        };
        self.stop = function () {
          self.sound.pause();
        }
      }


      // constructor for background
       function Background (width, height, x, y, src) {
         var self = this;
         self.image = new Image();
         self.image.src = src;
         self.width = width;
         self.height = height;
         self.speedY = 0;
         self.posX = x;
         self.posY = y;
         self.update = function () {
           var ctx = myGameArea.context;
           ctx.drawImage(self.image, self.posX, self.posY, self.width, self.height);
           ctx.drawImage(self.image, self.posX, self.posY - self.height, self.width, self.height);
         };
         self.changePos = function () {
           self.posY += self.speedY;
           if (self.posY >= self.height) { // more flexible option it's necessary when speed of background is high
             self.posY = 0;
           }
         };
       }


      // constructor for player car
      function Car (width, height, x, y, src) {
        var self = this;
        self.image = new Image();
        self.image.src = src;
        self.width = width;
        self.height = height;
        /*self.speedX = 0;
        self.speedY = 0;*/
        self.speed = 0;
        self.angle = 0;
        self.moveAngle = 0;
        self.actualAngle = 0;
        self.posX = x;
        self.posY = y;
        self.update = function () {
          var ctx = myGameArea.context;
          ctx.save(); // to save the current canvas context
          ctx.translate(self.posX, self.posY); // we move the entire canvas to the center of the specific component
          ctx.rotate(self.angle); // perform the wanted rotation using the rotate() method
          ctx.drawImage(self.image, self.width / -2, self.height / -2, self.width, self.height); //context.drawImage(img,x,y,width,height);
          ctx.restore(); // restore the context object back to its saved position
        };
        self.changePos = function () {
          self.actualAngle += self.moveAngle;
          if (self.actualAngle >= 360 || self.actualAngle <= -360) {
            self.actualAngle = 0;
          }
          self.angle += self.moveAngle * Math.PI / 180;
          self.posX += self.speed * Math.sin(self.angle);
          self.posY -= self.speed * Math.cos(self.angle);
        };
        self.crashWith = function (obstacleObj) {

          if (((self.actualAngle > -45) && (self.actualAngle < 45)) || ((self.actualAngle > 135) && (self.actualAngle < 225)) ||
              ((self.actualAngle < -135) && (self.actualAngle > -225)) || (self.actualAngle > 315)) {
            var myLeft = self.posX - self.width / 2;
            var myRight = self.posX + self.width / 2;
            var myTop = self.posY - self.height / 2;
            var myBottom = self.posY + self.height / 2;
          } else {
            var myLeft = self.posX - self.height / 2;
            var myRight = self.posX + self.height / 2;
            var myTop = self.posY - self.width / 2;
            var myBottom = self.posY + self.width / 2;
          }

          var obstacleBottom = obstacleObj.posY + obstacleObj.height;
          var obstacleTop = obstacleObj.posY;
          var obstacleRight = obstacleObj.posX + obstacleObj.width;
          var obstacleLeft = obstacleObj.posX;
          var crash = false;
          if((myTop < obstacleBottom) && (myBottom > obstacleTop)) {
            if ((myRight > obstacleLeft) && (myLeft < obstacleRight)) {
              crash = true;
            }
          }
          return crash;
        };
        self.touchWalls = function () {
          if (self.posX < 0) {
            self.posX = 0;
          }
          if (self.posX + self.width > GAMEAREAWIDTH) {
            self.posX = GAMEAREAWIDTH - self.width;
          }
          if (self.posY < 0) {
            self.posY = 0;
          }
          if (self.posY + self.height > GAMEAREAHEIGHT) {
            self.posY = GAMEAREAHEIGHT - self.height;
          }
        }
      }

      // constructor for obstacles
      function Obstacle (width, height, x, y) {
        var self = this;
        self.image = new Image();
        self.image.src = 'img/obstacles/car' + (Math.floor(Math.random()*(10 - 1 + 1)) + 1) + '.png'; // generate random src for image of obstacle
        self.width = width;
        self.height = height;
        self.posX = x;
        self.posY = y;
        self.update = function () {
          var ctx = myGameArea.context;
          ctx.drawImage(self.image, self.posX, self.posY, self.width, self.height);
        };
        self.move = function (speed) {
          self.posY += speed;
        }
      }

       window.addEventListener('keydown', moveCar, false);
       window.addEventListener('keyup', stopCar, false);



       // functions for control our car using keypad arrow keys
       // to move car
       function moveCar(EO) {
         EO = EO || window.event;
         song.play();
         switch (EO.which) {
           case 37:
             playerCar.moveAngle = -1 - backgroundSpeed / 2; // it should be connected with background speed, because without it player car will become uncontrollable at a high speed
             break;
           case 39:
             playerCar.moveAngle = 1 + backgroundSpeed / 2;
             break;
           case 40:
             playerCar.speed= -2 - backgroundSpeed / 2;
             break;
           case 38:
             playerCar.speed= 4 + backgroundSpeed / 2;
             break;
           default:
             break;
         }
       }

       // to stop car
       function stopCar(EO) {
         EO = EO || window.event;
         EO.preventDefault();
         switch (EO.which) {
           case 39:
           case 37:
             playerCar.moveAngle = 0;
             break;
           case 40:
           case 38:
             playerCar.speed= 0;
             break;
           default:
             break;
         }
       }

       // update of our game field
       requestAnimationFrame(updateGameArea);


       function updateGameArea() {
         for (var i = 0; i < obstacles.length; i += 1) {
           if (playerCar.crashWith(obstacles[i])) {
             stopGame();
             return;
           }
         }

         myGameArea.clear();
         background.speedY = backgroundSpeed;
         background.changePos();
         background.update();

         myGameArea.frameNo += 1;

         var xObstaclePos = Math.floor(Math.random()*(GAMEAREAWIDTH - OBSTACLEWIDTH) + 1); // for random x coordinate for obstacles
         if ((myGameArea.frameNo === 1) || everyObstacleInterval(100)) {
           obstacles.push(new Obstacle(OBSTACLEWIDTH, OBSTACLEHEIGHT, xObstaclePos, -100)); // -100 for smooth appearance of obstacles from top
         }
         for (var j = 0; j < obstacles.length; j += 1) {
           obstacles[j].move(obstacleSpeed);
           obstacles[j].update();
         }

         playerScore.text = 'SCORE:' + Math.floor(myGameArea.frameNo / 10); // define the speed of score increase
         playerScore.update();

         playerCar.changePos();
         playerCar.touchWalls();
         playerCar.update();

         obstacleSpeed += ACCELERATION;
         backgroundSpeed += ACCELERATION;

         requestAnimationFrame(updateGameArea);
       }

      function everyObstacleInterval(n) {
        return (myGameArea.frameNo / n) % 1 == 0; // would return true if (myGameArea.frameNo / n) was an integer, a%b returns surplus of the division of 2 operands
      }

      function stopGame() {
        crashSound.play();
        song.stop();
        window.removeEventListener('keydown', moveCar, false);
        window.removeEventListener('keyup', stopCar, false);
        cancelAnimationFrame(updateGameArea);
        var gameEndMenu = document.querySelector('.game-end-wrapper');
        gameEndMenu.style.display = 'block';
        var scoreEl = document.getElementById('score');
        scoreEl.innerHTML = ` Score: ${Math.floor(myGameArea.frameNo / 10)}`;
        var backgroundEl = document.querySelector('.game-end-background');
        backgroundEl.style.display = 'block';
      }


    </script>
  </body>
</html>