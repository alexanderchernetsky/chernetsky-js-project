<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="stylesheet" href="style.css">
    <title>racing game project</title>
  </head>
  <body>
    <div class="canvas-wrapper"></div>
    <script>
      'use strict';
      // constants
      var GAMEAREAWIDTH = 500; // width of our game area
      var GAMEAREAHEIGHT = 600; // height of our game area
      var PLAYERCARWIDTH = 50; // width of user car
      var PLAYERCARHEIGHT = 100; // height of user car
      var OBSTACLEWIDTH = 50; // width of obstacle
      var OBSTACLEHEIGHT = 100; // height of obstacle
      var SCORESIZE = 20; // the size of our score
      var BACKGROUNDIMAGEHEIGHT = 1349; //  it should be equal to full height of our background image

      var playerCar; // declare variable of user car
      var obstacles = [];// variable for our obstacles
      var obstacleSpeed = 2; // initial speed of moving obstacle = 2
      var playerScore; // declare variable of user score
      var background; // declare variable of game background
      var backgroundSpeed = 1; // initial speed od background moving


      // game area object
      var myGameArea = {
        canvas : document.createElement("canvas"),
        start : function() {
          this.canvas.width = GAMEAREAWIDTH;
          this.canvas.height = GAMEAREAHEIGHT;
          this.context = this.canvas.getContext("2d");
          document.querySelector('.canvas-wrapper').appendChild(this.canvas);
        },
        clear: function () {
          this.context.clearRect(0 , 0, GAMEAREAWIDTH, GAMEAREAHEIGHT);
        },
        frameNo: 0,
      };

      // creating empty game area canvas with background, car and score
      (function startGame() {
        myGameArea.start();
        background = new Component(GAMEAREAWIDTH, BACKGROUNDIMAGEHEIGHT, 0, 0, 'img/road.jpg', 'background');
        playerCar = new Component(PLAYERCARWIDTH, PLAYERCARHEIGHT, 230, 500, 'img/player-car.png', 'image');
        playerScore = new Counter(SCORESIZE, 20, 20);
      }());


      // constructor for score counter
      function Counter (size, x, y) {
        var self = this;
        self.text = 'SCORE:';
        self.update = function () {
          var ctx = myGameArea.context;
          ctx.fillStyle = 'white';
          ctx.font = 'italic bold ' + size + 'px Arial';
          ctx.fillText(self.text, x, y);
        };
      }

      // constructor for player car and background
       function Component (width, height, x, y, src, type) {
         var self = this;
         self.type = type;
         self.image = new Image();
         self.image.src = src;
         self.width = width;
         self.height = height;
         self.speedX = 0;
         self.speedY = 0;
         self.posX = x;
         self.posY = y;
         self.update = function () {
           var ctx = myGameArea.context;
           if (self.type === 'image' || self.type === 'background') {
             ctx.drawImage(self.image, self.posX, self.posY, self.width, self.height);
           }
           if (self.type === 'background') { // in case we draw background, we should draw 2 images and one of them should have y = posY - height
             ctx.drawImage(self.image, self.posX, self.posY - self.height, self.width, self.height)
           }
         };
         self.changePos = function () {
           self.posX += self.speedX;
           self.posY += self.speedY;
           if (self.type === 'background') { // when our background reached the y coordinate equal it's height(the end of the image) the loop should start from the beginning
              if (self.posY === self.height) {
                self.posY = 0;
              }
           }
         };
         self.crashWith = function (obstacleObj) {
           var myBottom = self.posY + self.height;
           var myTop = self.posY;
           var myRight = self.posX + self.width;
           var myLeft = self.posX;
           var obstacleBottom = obstacleObj.posY + obstacleObj.height;
           var obstacleTop = obstacleObj.posY;
           var obstacleRight = obstacleObj.posX + obstacleObj.width;
           var obstacleLeft = obstacleObj.posX;
           var crash = false;
           if((myTop < obstacleBottom) && (myBottom > obstacleTop)) {
             if ((myRight > obstacleLeft) && (myLeft < obstacleRight)) {
               crash = true;
             }
           }
           return crash;
         };
         self.touchWalls = function () {
           if (self.posX < 0) {
             self.posX = 0;
           }
           if (self.posX + self.width > GAMEAREAWIDTH) {
             self.posX = GAMEAREAWIDTH - self.width;
           }
           if (self.posY < 0) {
             self.posY = 0;
           }
           if (self.posY + self.height > GAMEAREAHEIGHT) {
             self.posY = GAMEAREAHEIGHT - self.height;
           }
         }
       }

      // constructor for obstacles
      function Obstacle (width, height, x, y) {
        var self = this;
        self.image = new Image();
        self.image.src = 'img/obstacles/car' + (Math.floor(Math.random()*(10 - 1 + 1)) + 1) + '.png'; // generate random src for image of obstacle
        self.width = width;
        self.height = height;
        self.posX = x;
        self.posY = y;
        self.update = function () {
          var ctx = myGameArea.context;
          ctx.drawImage(self.image, self.posX, self.posY, self.width, self.height);
          /*ctx.fillStyle = 'green';
          ctx.fillRect(self.posX, self.posY, self.width, self.height);*/
        };
        self.move = function (speed) {
          self.posY += speed;
        }
      }

       window.addEventListener('keydown', moveCar, false);
       window.addEventListener('keyup', stopCar, false);

       // functions for control our car using keypad arrow keys
       // to move car
       function moveCar(EO) {
         EO = EO || window.event;
         switch (EO.which) {
           case 37:
             playerCar.speedX = -4;
             break;
           case 39:
             playerCar.speedX = 4;
             break;
           case 40:
             playerCar.speedY = 4;
             break;
           case 38:
             playerCar.speedY = -4;
             break;
           default:
             break;
         }
       }

       // to stop car
       function stopCar(EO) {
         EO = EO || window.event;
         EO.preventDefault();
         switch (EO.which) {
           case 39:
           case 37:
             playerCar.speedX = 0;
             break;
           case 40:
           case 38:
             playerCar.speedY = 0;
             break;
           default:
             break;
         }
       }

       // update of our game field
       requestAnimationFrame(updateGameArea);

       function updateGameArea() {
         for (var i = 0; i < obstacles.length; i += 1) {
           if (playerCar.crashWith(obstacles[i])) {
             cancelAnimationFrame(updateGameArea);
             return;
           }
         }

         myGameArea.clear();
         background.speedY = backgroundSpeed;
         background.changePos();
         background.update();

         myGameArea.frameNo += 1;

         var xObstaclePos = Math.floor(Math.random()*(GAMEAREAWIDTH - OBSTACLEWIDTH) + 1); // for random x coordinate for obstacles
         if ((myGameArea.frameNo === 1) || everyObstacleInterval(100)) {
           obstacles.push(new Obstacle(OBSTACLEWIDTH, OBSTACLEHEIGHT, xObstaclePos, -100)); // -100 for smooth appearance of obstacles from top
         }
         for (var j = 0; j < obstacles.length; j += 1) {
           obstacles[j].move(obstacleSpeed);
           obstacles[j].update();
         }

         playerScore.text = 'SCORE:' + Math.floor(myGameArea.frameNo / 10); // define the speed of score increase
         playerScore.update();

         playerCar.changePos();
         playerCar.touchWalls();
         playerCar.update();

         requestAnimationFrame(updateGameArea);
       }

      function everyObstacleInterval(n) {
        return (myGameArea.frameNo / n) % 1 == 0; // would return true if (myGameArea.frameNo / n) was an integer, a%b returns surplus of the division of 2 operands
      }

    </script>
  </body>
</html>