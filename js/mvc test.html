<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>mvc test</title>
</head>
<body>
  <script>
    const raceGame = {
      GAMEAREAWIDTH: 500, // width of our game area
      GAMEAREAHEIGHT: 600, // height of our game area
      playerCar: undefined, // declare variable of user car
      playerCarView: undefined,
      playerCarController: undefined,
    };

    // game area object
    const myGameArea = {
      canvas: document.createElement('canvas'),
      start() {
        this.canvas.width = raceGame.GAMEAREAWIDTH;
        this.canvas.height = raceGame.GAMEAREAHEIGHT;
        this.context = this.canvas.getContext('2d');
        document.body.appendChild(this.canvas);
      },
      clear() {
        this.context.clearRect(0, 0, raceGame.GAMEAREAWIDTH, raceGame.GAMEAREAHEIGHT);
      },
    };

    // model
    function CarModel(obj) {
      this.image = new Image();
      this.image.src = obj.src;
      this.width = obj.width;
      this.height = obj.height;
      this.posX = obj.x;
      this.posY = obj.y;
      this.speed = 0;
      this.moveAngle = 0; // the rotation angle which we will change when push keyboard button left/right keys, in deg
      this.angle = 0; // the same angle,but in radians
      this.actualAngle = 0; // current rotation angle of the car from -360 to 360, in degrees

      var myView = null;

      this.start = function (view) {
        myView = view;
      };

      this.updateView = function () {
        // при любых изменениях модели попадаем сюда
        // представление может быть любым,
        // лишь бы имело метод Update()
        if (myView)
          myView.update();
      };

      this.shift = function (raceGameObj) {
        var raceGame = raceGameObj;
        // touch walls
        if (this.posX < this.width) {
          this.posX = this.width;
        }
        if (this.posX + this.width > raceGame.GAMEAREAWIDTH) {
          this.posX = raceGame.GAMEAREAWIDTH - this.width;
        }
        if (this.posY < this.height / 2) {
          this.posY = this.height / 2;
        }
        if (this.posY + this.height / 2 > raceGame.GAMEAREAHEIGHT) {
          this.posY = raceGame.GAMEAREAHEIGHT - this.height / 2;
        }

        this.actualAngle += this.moveAngle;
        if (this.actualAngle >= 360 || this.actualAngle <= -360) {
          this.actualAngle = 0;
        }
        this.angle += this.moveAngle * Math.PI / 180;
        this.posX += this.speed * Math.sin(this.angle);
        this.posY -= this.speed * Math.cos(this.angle);
        this.updateView(); // модель при любых изменениях
        // вызывает обновление представления
      };

      this.changeMoveAngle = function (angle) {
        this.moveAngle = angle;
      };

      this.changeSpeed = function (speed) {
        this.speed = speed;
      }
    }

    // view
    function CarView() {
      var myModel = null; // с какой моделью работаем
      var myField = null; // внутри какого элемента DOM наша вёрстка

      this.start = function (model, field) {
        myModel = model;
        myField = field;
      };

      this.update = function () {
        const ctx = myField.context;
        ctx.save(); // to save the current canvas context
        ctx.translate(myModel.posX, myModel.posY); // we move the entire canvas to the center of the specific component
        ctx.rotate(myModel.angle); // perform the wanted rotation using the rotate() method
        ctx.drawImage(myModel.image, myModel.width / -2, myModel.height / -2, myModel.width, myModel.height); // context.drawImage(img,x,y,width,height);
        ctx.restore(); // restore the context object back to its saved position
      }
    }

    // controller
    function CarController() {
      var myModel = null;
      var myField = null; // внутри какого элемента DOM наша вёрстка

      this.start = function (Model, Field) {
        myModel = Model;
        myField = Field;
        // ищем и запоминаем интересные нам элементы DOM
        // назначаем обработчики событий
        window.addEventListener('keydown', this.moveCar, false);
        window.addEventListener('keyup', this.stopCar, false);
      };

      this.moveCar = function (EO) {
        EO = EO || window.event; // there is no preventDefault because we need f12 default behavior
        switch (EO.which) {
          case 37:
            myModel.changeMoveAngle(-1); // контроллер вызывает только методы модели
            break;
          case 39:
            myModel.changeMoveAngle(1);
            break;
          case 40:
            myModel.changeSpeed(-2);
            break;
          case 38:
            myModel.changeSpeed(4);
            break;
          default:
            break;
        }
      };

      this.stopCar = function (EO) {
        EO = EO || window.event;
        EO.preventDefault();
        switch (EO.which) {
          case 39:
          case 37:
            myModel.changeMoveAngle(0);// контроллер вызывает только методы модели
            break;
          case 40:
          case 38:
            myModel.changeSpeed(0);
            break;
          default:
            break;
        }
      }
    }

    (function startGame() {
      myGameArea.start();
      // настройка, инициализация
      // создаём все три компонента
      /*Создаём объекты модели, представления, контроллера.
      Пока что они друг о друге ничего не знают.*/
      raceGame.playerCar = new CarModel({
        width: 50, height: 100, x: 230, y: 500, src: '../img/player-car.png',
      });
      raceGame.playerCarView = new CarView();
      raceGame.playerCarController = new CarController();
      // увязываем компоненты друг с другом
      // указываем компонентам, в каком DOM им работать
      /*Увязываем все компоненты друг с другом, и сообщаем контроллеру
      и представлению, в каком DOM-элементе содержится нужная им вёрстка.*/
      raceGame.playerCar.start(raceGame.playerCarView);
      raceGame.playerCarView.start(raceGame.playerCar, myGameArea);
      raceGame.playerCarController.start(raceGame.playerCar, myGameArea);
      /*Это уже гибкая реализация активного MVC, которая
      при желании легко будет работать с несколькими
      представлениями одной модели, несколькими контроллерами
      одной модели, или вообще с несколькими комплектами
      всех компонентов на одной странице.*/
      // update of our game field
      requestAnimationFrame(updateGameArea);
    })();

    function updateGameArea() {
      // clear our canvas
      myGameArea.clear();
      //  change player car position, check if it within the canvas borders and render it
      raceGame.playerCar.shift(raceGame);
      requestAnimationFrame(updateGameArea);
    }

  </script>

</body>
</html>